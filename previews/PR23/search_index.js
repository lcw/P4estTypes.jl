var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"P4estTypes.jl is a high-level Julia interface to p4est a distributed (via MPI) forest-of-octrees C library. P4estTypes.jl uses the lower-level wrappers from P4est.jl to interface with p4est.","category":"page"},{"location":"usage/#Installation","page":"Usage","title":"Installation","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"It is required to install MPI.jl alongside P4estTypes.jl.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> using Pkg; Pkg.add([\"MPI\", \"P4estTypes\"])","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This uses the default MPI library distributed with MPI.jl.  If you would like to use another MPI installation you need to make sure that MPI.jl points to the correct MPI installation.  P4est.jl must also point to a p4est C library compiled for the desired MPI installation.  Detailed instructions for doing this may be found here.","category":"page"},{"location":"usage/#Basic-example","page":"Usage","title":"Basic example","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here we present a basic example of a forest-of-quadtrees distributed among 2 MPI ranks.  We will use tmpi to interactively investigate the forest.  In practice MPI-based codes are launched in a non-interactive mode via mpiexec.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We create a project with MPI.jl and P4estTypes.jl and ensure everything is precompiled (we can run into trouble having multiple ranks trying to precompile at the same time).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia --project=. -e 'using Pkg; Pkg.add([\"MPI\", \"P4estTypes\"]); Pkg.API.precompile()'","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We begin by launch an interactive session with 2 MPI ranks from our shell prompt.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"$ tmpi 2 julia --project","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Next, we on both ranks we declare the packages we are using and initialize MPI. Importantly, MPI must be initialized before P4estTypes functions are called.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> using P4estTypes, MPI; MPI.Init();","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"On each rank, a three element (in the x-direction) nonperiodic connectivity is constructed with","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> conn = brick(3, 1)\nConnectivity{4}\nnote: the following entries are zero-based\n\ntrees:\n3-element reinterpret(reshape, NTuple{4, Int32}, ::Matrix{Int32}) with eltype NTuple{4, Int32}:\n (0, 1, 2, 3)\n (1, 4, 3, 5)\n (4, 6, 5, 7)\nvertices:\n8-element reinterpret(reshape, Tuple{Float64, Float64, Float64}, ::Matrix{Float64}) with eltype Tuple{Float64, Float64, Float64}:\n (0.0, 0.0, 0.0)\n (1.0, 0.0, 0.0)\n (0.0, 1.0, 0.0)\n (1.0, 1.0, 0.0)\n (2.0, 0.0, 0.0)\n (2.0, 1.0, 0.0)\n (3.0, 0.0, 0.0)\n (3.0, 1.0, 0.0)\ntree to tree:\n3-element reinterpret(reshape, NTuple{4, Int32}, ::Matrix{Int32}) with eltype NTuple{4, Int32}:\n (0, 1, 0, 0)\n (0, 2, 1, 1)\n (1, 2, 2, 2)\ntree to face:\n3-element reinterpret(reshape, NTuple{4, Int8}, ::Matrix{Int8}) with eltype NTuple{4, Int8}:\n (0, 0, 2, 3)\n (1, 0, 2, 3)\n (1, 1, 2, 3)\ntree to corner:\n0-element reinterpret(reshape, NTuple{4, Int32}, ::Matrix{Int32}) with eltype NTuple{4, Int32}\ncorners:\n3×0 SparseArrays.SparseMatrixCSC{Int8, Int64} with 0 stored entries","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The REPL shows the underlying data stored for this connectivity (note that it is zero-based).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Next we can construct a uniform forest with 1 level of refinement from this connectivity.  We now show the REPL output of each rank individually as the output is different.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 0 output building the forest\njulia> forest = pxest(conn; min_level=1)\nForest{4} with 3 trees.\n├─ Tree{4} with 4 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n├─ Tree{4} with 2 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 0).\n└─ Tree{4} with 0 quadrants.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 1 output building the forest\njulia> forest = pxest(conn; min_level=1)\nForest{4} with 3 trees.\n├─ Tree{4} with 0 quadrants.\n├─ Tree{4} with 2 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n└─ Tree{4} with 4 quadrants.\n   ├─ Quadrant{4}: level 1, coordinates (0, 0).\n   ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n   ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n   └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The forest is an array-of-arrays data structure containing all the quadrants. Note that each rank stores only the quadrants in its rank-local domain.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Above, we see that rank 0 has an array for each tree in conn but only some of those arrays have Quadrants in them.  Specifically, all of the quadrants from tree 1 and half of the quadrants from tree 2.  Rank 1 contains the remaining quadrants.  The coordinates of the quadrants are given in tree-local integer coordinates.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We can get a visual representation of the forest by saving VTK files and viewing them in Paraview.  Running","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> savevtk(\"initialforest\", forest)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"generates one .vtu file for each rank, here initialforest_0000.vtu and initialforest_0001.vtu, and the collections file initialforest.pvtu and initialforest.visit.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We currently have the sibling quadrants (quadrants that have the same parent) in tree 2 distributed among both ranks.  We are not able to coarsen siblings that live on different ranks.  So we may want to partition the mesh in a way that keeps siblings together.  This can be done with","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> partition!(forest; allow_for_coarsening=true)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We now show the mesh on each rank.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 0 output of the newly partitioned mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 4 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n├─ Tree{4} with 4 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n└─ Tree{4} with 0 quadrants.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 1 output of the newly partitioned mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 0 quadrants.\n├─ Tree{4} with 0 quadrants.\n└─ Tree{4} with 4 quadrants.\n   ├─ Quadrant{4}: level 1, coordinates (0, 0).\n   ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n   ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n   └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Rank 0 gets the first 2 sibling groups and rank 1 gets the other.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We can now coarsen the elements in tree 2 with","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> coarsen!(forest; coarsen = (_, treeid, _) -> treeid == 2 )","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"which gives the distribution","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 0 output of the coarsened mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 4 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n├─ Tree{4} with 1 quadrants.\n│  └─ Quadrant{4}: level 0, coordinates (0, 0).\n└─ Tree{4} with 0 quadrants.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 1 output of the coarsened mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 0 quadrants.\n├─ Tree{4} with 0 quadrants.\n└─ Tree{4} with 4 quadrants.\n   ├─ Quadrant{4}: level 1, coordinates (0, 0).\n   ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n   ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n   └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We see that tree 2 only has 1 quadrant now at the root of the tree.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We are now going to refine the quadrant in tree 1 with coordinates (536870912, 0) with","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> refine!(forest;\n               refine = (_, treeid, quad) -> treeid == 1 &&\n                                             coordinates(quad) == (536870912, 0)\n              )","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"which gives","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 0 output of the refined mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 7 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  ├─ Quadrant{4}: level 2, coordinates (536870912, 0).\n│  ├─ Quadrant{4}: level 2, coordinates (805306368, 0).\n│  ├─ Quadrant{4}: level 2, coordinates (536870912, 268435456).\n│  ├─ Quadrant{4}: level 2, coordinates (805306368, 268435456).\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n├─ Tree{4} with 1 quadrants.\n│  └─ Quadrant{4}: level 0, coordinates (0, 0).\n└─ Tree{4} with 0 quadrants.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 1 output of the refined mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 0 quadrants.\n├─ Tree{4} with 0 quadrants.\n└─ Tree{4} with 4 quadrants.\n   ├─ Quadrant{4}: level 1, coordinates (0, 0).\n   ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n   ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n   └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We see that we have level 2 elements now in tree 1.  These neighbor the level 0 element in tree 2.  The mesh is unbalanced because there are quadrants differing by more than one level that share an edge.  We bring this back to a 1 level difference by enforcing the 2-to-1 constraint with","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> balance!(forest)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"which gives","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 0 output of the balanced mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 7 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  ├─ Quadrant{4}: level 2, coordinates (536870912, 0).\n│  ├─ Quadrant{4}: level 2, coordinates (805306368, 0).\n│  ├─ Quadrant{4}: level 2, coordinates (536870912, 268435456).\n│  ├─ Quadrant{4}: level 2, coordinates (805306368, 268435456).\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n├─ Tree{4} with 4 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n└─ Tree{4} with 0 quadrants.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 1 output of the balanced mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 0 quadrants.\n├─ Tree{4} with 0 quadrants.\n└─ Tree{4} with 4 quadrants.\n   ├─ Quadrant{4}: level 1, coordinates (0, 0).\n   ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n   ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n   └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"There are now 11 quadrants on rank 0 and 4 on rank 1.  We can more evenly distribute the quadrants with","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> partition!(forest; allow_for_coarsening=true)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"which gives","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 0 output of the partitioned mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 7 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  ├─ Quadrant{4}: level 2, coordinates (536870912, 0).\n│  ├─ Quadrant{4}: level 2, coordinates (805306368, 0).\n│  ├─ Quadrant{4}: level 2, coordinates (536870912, 268435456).\n│  ├─ Quadrant{4}: level 2, coordinates (805306368, 268435456).\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n├─ Tree{4} with 0 quadrants.\n└─ Tree{4} with 0 quadrants.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 1 output of the partitioned mesh\njulia> forest\nForest{4} with 3 trees.\n├─ Tree{4} with 0 quadrants.\n├─ Tree{4} with 4 quadrants.\n│  ├─ Quadrant{4}: level 1, coordinates (0, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n│  ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n│  └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).\n└─ Tree{4} with 4 quadrants.\n   ├─ Quadrant{4}: level 1, coordinates (0, 0).\n   ├─ Quadrant{4}: level 1, coordinates (536870912, 0).\n   ├─ Quadrant{4}: level 1, coordinates (0, 536870912).\n   └─ Quadrant{4}: level 1, coordinates (536870912, 536870912).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This is a more even partitioning with 7 quadrants on rank 0 and 8 quadrants on rank 2.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now that we have the forest adapted as desired we would like to access the quadrants of the forest.  There are currently two API for doing this.  The first is the arrays-of-arrays approach.  Let's get the 2nd quadrant in tree 1.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 0 output accessing 2nd quadrant in tree 1\njulia> forest[1][2]\nQuadrant{4}: level 2, coordinates (536870912, 0).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 1 output accessing 2nd quadrant in tree 1\njulia> forest[1][2]\nERROR: BoundsError: attempt to access 0-element P4estTypes.Tree{4, Nothing, Ptr{P4est.LibP4est.p4est_tree}, Pxest{4, Nothing, Ptr{P4est.LibP4est.p4est}, Connectivity{4, Ptr{P4est.LibP4est.p4est_connectivity}}}} at index [2]\nStacktrace:\n [1] throw_boundserror(A::P4estTypes.Tree{4, Nothing, Ptr{P4est.LibP4est.p4est_tree}, Pxest{4, Nothing, Ptr{P4est.LibP4est.p4est}, Connectivity{4, Ptr{P4est.LibP4est.p4est_connectivity}}}}, I::Tuple{Int64})\n   @ Base ./abstractarray.jl:744\n [2] checkbounds\n   @ ./abstractarray.jl:709 [inlined]\n [3] getindex(t::P4estTypes.Tree{4, Nothing, Ptr{P4est.LibP4est.p4est_tree}, Pxest{4, Nothing, Ptr{P4est.LibP4est.p4est}, Connectivity{4, Ptr{P4est.LibP4est.p4est_connectivity}}}}, i::Int64)\n   @ P4estTypes ~/research/code/julia/P4estTypes/src/pxest.jl:315\n [4] top-level scope\n   @ REPL[35]:1We get an error message here because rank 1 doesn't have any elements in tree 1.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We can also access the quadrants through the p4est iterator function, iterateforest.  This function iterates over the volumes, faces, edges, and corners of the forest via callback functions.  To show the quadrants with tree coordinates (0, 0) we can run","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> iterateforest(forest;\n                     volume = (_, _, quad, _, treeid, _) ->\n                         (coordinates(quad) == (0, 0) &&\n                          (@show (treeid, quad))))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"to print","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 0 output calling `iterateforest`\n(treeid, quad) = (1, Quadrant{4}: level 1, coordinates (0, 0).)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"output: Rank 1 output calling `iterateforest`\n(treeid, quad) = (2, Quadrant{4}: level 1, coordinates (0, 0).)\n(treeid, quad) = (3, Quadrant{4}: level 1, coordinates (0, 0).)","category":"page"},{"location":"reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = P4estTypes","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [P4estTypes]","category":"page"},{"location":"reference/#P4estTypes.Connectivity","page":"Reference","title":"P4estTypes.Connectivity","text":"Connectivity{X,P}\n\nConnectivity for a Pxest which holds the mesh information for the roots of Pxest quadtrees or octrees. The parameter X is 4 if the roots are quads (2D aka p4est) and 8 if they are hexes (3D aka p8est).\n\nFields\n\npointer: The pointer (of type P) can be a pointer to either a P4estTypes.P4est.p4est_connectivity or a P4estTypes.P4est.p8est_connectivity.  See the help documentation for these types for more information about the underlying p4est structures.\n\nUsage\n\nConnectivity{4}(name::Symbol)\n\nConstruct a connectivity mesh for the roots of a forest-of-quadtrees using p4est's built-in mesh connectivities.  Valid values for name are\n\n:unitsquare: the unit square.\n:periodic: all-periodic unit square.\n:rotwrap: periodic unit square (the left and right faces are identified, and bottom and top opposite).\n:corner: three-tree mesh around a corner.\n:pillow: two trees on top of each other.\n:moebius: a five-tree moebius band.\n:star: six-tree star.\n:cubed: six sides of a unit cube.\n:disk_nonperiodic: five-tree flat spherical disk.\n:icosahedron: for mapping the sphere using an icosahedron (see @doc P4estTypes.P4est.p4est_connectivity_new_icosahedron for more info).\n:shell2d: 2D spherical shell.\n:disk2d: maps a 2D disk.\n\n\n\nConnectivity{4}(:disk, periodic_x::Bool, periodic_y::Bool)\n\nCreate a connectivity structure for a five-tree flat spherical disk.  The arguments periodic_x and periodic_y determine if the disk is periodic in the x and y directions, respectively.\n\nSee @doc P4estTypes.P4est.p4est_connectivity_new_disk for detailed information.\n\n\n\nConnectivity{8}(name::Symbol)\n\nConstruct a connectivity mesh for the roots of a forest-of-octrees using p8est's built-in mesh connectivities.  Valid values for name are\n\n:unitcube: the unit cube.\n:periodic: an all-periodic unit cube.\n:rotcubes: contains a few cubes (these are rotated against each other to stress the topology routines).\n:rotwrap: a mostly periodic unit cube (see @doc P4estTypes.P4est.p8est_connectivity_new_rotwrap).\n:shell: a spherical shell (see @doc P4estTypes.P4est.p8est_connectivity_new_shell).\n:sphere: a solid sphere (see @doc P4estTypes.P4est.p8est_connectivity_new_sphere).\n:twocubes: two cubes.\n:twowrap: two cubes where the two far ends are identified periodically.\n\n\n\nConnectivity{8}(:torus, nsegments)\n\nCreate a connectivity structure that builds a revolution torus.  Here nsegments are the number of trees along the great circle.\n\nSee @doc P4estTypes.P4est.p8est_connectivity_new_torus for detailed information.\n\n\n\nConnectivity{8}(:torus, nsegments)\n\nCreate a connectivity structure that builds a revolution torus.  Here nsegments are the number of trees along the great circle.\n\nSee @doc P4estTypes.P4est.p8est_connectivity_new_torus for detailed information.\n\n\n\nConnectivity{X}(:twotrees, l_face, r_face, orientation) where {X}\n\nCreate a connectivity structure (X=4 for quadtrees and X=8 for octrees) for two trees being rotated with respect to each other in a user-defined way.  Here l_face and r_face are the 0-based indices of left and right faces, respectively. The argument orientation gives the orientation code of the trees with respect to each other.\n\n\n\nConnectivity{X}(vertices, elements) where {X}\n\nCreates a connectivity from the given list of vertices and element-to-vertex connectivity.  The parameter set to X=4 is for quads and X=8 for hexes.\n\nvertices: should be a number-of-vertices by 3 matrix where the columns correspond to x, y, and z coordinates (typically the z coordinate will be zero for a 2D forest).\nelements: should be a number-of-vertices by 4 or 8 matrix where the columns vertex indices used to define each element. Note that z-ordering should be used, and it should use zero-indexing.\n\n\n\nConnectivity{X}(filename::String) where {X}\n\nCreate a connectivity from an ABAQUS input at filename. The parameter set to X=4 is for quads and X=8 for hexes.\n\nSee @doc P4estTypes.P4est.p4est_connectivity_read_inp and @doc P4estTypes.P4est.p8est_connectivity_read_inp for example ABAQUS input files.\n\nSee also\n\nbrick: a function to create a rectangular Connectivity.\nconnectivity: a function to get the connectivity of a Pxest.\nrefine: a function to create a refined Connectivity.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.GhostLayer","page":"Reference","title":"P4estTypes.GhostLayer","text":"GhostLayer{X,T,P}\n\nStores a ghost layer of quadrants that neighbor the domain local to the rank for a Pxest{X,T}.  Also stores the corresponding local domain quadrants, mirrors, that are in other rank's ghost layers.\n\nFields\n\npointer: The pointer (of type P) can be a pointer to either a P4estTypes.P4est.p4est_ghost_t or a P4estTypes.P4est.p8est_ghost_t.  See the help documentation for these types for more information about the underlying p4est structures.\n\nSee also\n\nghostlayer: a function used to construct a GhostLayer\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.LNodes","page":"Reference","title":"P4estTypes.LNodes","text":"LNodes{X,P}\n\nStores a parallel numbering of Lobatto nodes for a Pxest{X}.\n\nFields\n\npointer: The pointer (of type P) can be a pointer to either a P4estTypes.P4est.p4est_lnodes_t or a P4estTypes.P4est.p8est_lnodes_t.  See the help documentation for these types for more information about the underlying p4est structures.\ncomm: The MPI Communicator that includes the ranks participating in the lnods.\n\nSee also\n\nlnodes: a function used to construct LNodes\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.Pxest","page":"Reference","title":"P4estTypes.Pxest","text":"Pxest{X,T,P,C} <: AbstractArray{P4estTypes.Tree,1}\n\nStores the forest of quadtrees (when X=4) or octrees (when X=8).  The quadrants have user data of type T.\n\nThis forest of octrees can be accessed in two ways.  First, as an array-of-arrays. Each rank holds an array of quadrants for each tree of the Connectivity associated with the forest. (Note, the quadrants are distributed among the ranks. So, each rank will only have access to the quadrants it owns.) Second, using iterateforest to iterate over the volumes, faces, edges, and corners of the forest via callback functions.\n\nFields\n\npointer: The pointer (of type P) can be a pointer to either a P4estTypes.P4est.LibP4est.p4est or a P4estTypes.P4est.LibP4est.p8est.  See the help documentation for these types for more information about the underlying p4est structures.\nconnectivity: The connectivity (of type C) the forest is associated with.  This is stored so the connectivity will not be reclaimed by the garbage collector too early.\ncomm: The MPI Communicator that includes the ranks participating in the forest.\n\nSee also\n\npxest: a function that constructs a Pxest from a Connectivity.\niterateforest: a function to iterate over the volumes, faces, edges, and corners of the forest.\nrefine!: refine the quadrants of the forest.\ncoarsen!: coarsen the quadrants of the forest.\nbalance!: two-to-one balance the quadrants of the forest.\npartition!: partition the quadrants of the forest.\nghostlayer: get the ghost layer of quadrants for the forest.\nlnodes: get a global node numbering.\nP4estTypes.savevtk: save a VTK representation of the forest.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.Quadrant","page":"Reference","title":"P4estTypes.Quadrant","text":"Quadrant{X,T,P}\n\nStores a Pxest{X,T} quadrant (where X=4 indicates a quadrant and X=8 indicates an octant; quadrant is used both as the general term and the term for the 2D object) with user data of type T.\n\nFields\n\npointer: The pointer (of type P) can be a pointer to either a P4estTypes.P4est.p4est_quadrant or a P4estTypes.P4est.p8est_quadrant.  See the help documentation for these types for more information about the underlying p4est structures.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.Tree","page":"Reference","title":"P4estTypes.Tree","text":"Tree{X,T,P,Q} <: AbstractArray{Quadrant,1}\n\nStores the quadrants in a tree of a Pxest{X, T}.\n\nFields\n\npointer: The pointer (of type P) can be a pointer to either a P4estTypes.P4est.p4est_tree or a P4estTypes.P4est.p8est_tree.  See the help documentation for these types for more information about the underlying p4est structures.\nforest: The forest (of type Q) the tree is associated with.  This is stored so the forest will not be reclaimed by the garbage collector too early.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.CONNECT_CORNER-Tuple{Val{4}}","page":"Reference","title":"P4estTypes.CONNECT_CORNER","text":"P4estTypes.CONNECT_CORNER(::Val{4})\n\nReturns an integer indicating connecting quadrants across faces and corners.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.CONNECT_CORNER-Tuple{Val{8}}","page":"Reference","title":"P4estTypes.CONNECT_CORNER","text":"P4estTypes.CONNECT_CORNER(::Val{8})\n\nReturns an integer indicating connecting octants across faces, edges, and corners.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.CONNECT_EDGE-Tuple{Val{8}}","page":"Reference","title":"P4estTypes.CONNECT_EDGE","text":"P4estTypes.CONNECT_EDGE(::Val{8})\n\nReturns an integer indicating connecting octants across faces and edges.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.CONNECT_FACE-Tuple{Val{4}}","page":"Reference","title":"P4estTypes.CONNECT_FACE","text":"P4estTypes.CONNECT_FACE(::Val{4})\n\nReturns an integer indicating connecting quadrants across faces.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.CONNECT_FACE-Tuple{Val{8}}","page":"Reference","title":"P4estTypes.CONNECT_FACE","text":"P4estTypes.CONNECT_FACE(::Val{8})\n\nReturns an integer indicating connecting octants across faces.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.CONNECT_FULL-Tuple{Val{4}}","page":"Reference","title":"P4estTypes.CONNECT_FULL","text":"P4estTypes.CONNECT_FULL(::Val{4})\n\nReturns an integer indicating connecting quadrants across faces and corners.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.CONNECT_FULL-Tuple{Val{8}}","page":"Reference","title":"P4estTypes.CONNECT_FULL","text":"P4estTypes.CONNECT_FULL(::Val{8})\n\nReturns an integer indicating connecting octants across faces, edges, and corners.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.balance!-Union{Tuple{Pxest{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.balance!","text":"balance!(forest; kw...)\n\nEnforce the two-to-one quadrant size constraint across the forest.  By default, this constraint is enforced across faces, edges, and corners.\n\nThe keyword arguments (kw...) for the balancing are:\n\nconnect: type of constraint enforced which can take the values:\nP4estTypes.CONNECT_FULL(Val(4)): enforce across face, and corner.\nP4estTypes.CONNECT_FULL(Val(8)): enforce across face, edge, and corner.\nP4estTypes.CONNECT_FACE(Val(4)): enforce across face.\nP4estTypes.CONNECT_FACE(Val(8)): enforce across face.\nP4estTypes.CONNECT_EDGE(Val(8)): enforce across face and edge.\nP4estTypes.CONNECT_CORNER(Val(4)): enforce across face and corner.\nP4estTypes.CONNECT_CORNER(Val(8)): enforce across face, edge, and corner.\ninit = nothing: callback function with prototype init(forest, treeid, quadrant) called for each quadrant created to initialized the user data.\nreplace = nothing: callback function with prototype replace(forest, treeid, outgoing, incoming) called for each outgoing quadrant with their associated incoming quadrants. Note both outgoing and incoming are arrays with eltype Quadrant.\n\nSee @doc P4estTypes.P4est.p4est_balance_ext and @doc P4estTypes.P4est.p8est_balance_ext for more information about the underlying p4est balance functions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.brick","page":"Reference","title":"P4estTypes.brick","text":"brick(n::NTuple{3, Integer}, p::NTuple{3, Bool}=(false, false, false))\n\nReturns a new Connectivity that is a rectangular n[1]-by-n[2]-by-n[3] octree mesh.  The brick is periodic in x, y, and z if p[1], p[2], and p[3] are true, respectively.\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4estTypes.brick-2","page":"Reference","title":"P4estTypes.brick","text":"brick(n::NTuple{2, Integer}, p::NTuple{2, Bool}=(false, false))\n\nReturns a new Connectivity that is a rectangular n[1]-by-n[2] quadtree connectivity.  The brick is periodic in x and y if p[1] and p[2] are true, respectively.\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4estTypes.brick-3","page":"Reference","title":"P4estTypes.brick","text":"brick(l, m, p=false, q=false)\n\nReturns a new Connectivity that is a rectangular l-by-m quadtree mesh.  The brick is periodic in x and y if p and q are true, respectively.\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4estTypes.brick-4","page":"Reference","title":"P4estTypes.brick","text":"brick(l, m, n, p=false, q=false, r=false)\n\nReturns a new Connectivity that is a rectangular l-by-m-by-n octree mesh.  The brick is periodic in x, y, and z if p, q, and r are true, respectively.\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4estTypes.coarsen!-Union{Tuple{Pxest{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.coarsen!","text":"coarsen!(forest; coarsen = (_...) -> false, kw...)\n\nCoarsen the quadrants of the forest determined by the coarsen callback. The coarsen(forest, treeid, siblings) callback is called for each set of sibling quadrants local to the rank that are eligible for coarsening. If the callback returns true the siblings will coarsen into one quadrant otherwise they will be untouched.\n\nThe other keyword arguments (kw...) for the coarsening are:\n\nrecursive = false: if true coarsening will be recursive otherwise each set of rank-local siblings will only be visited once.\ninit = nothing: callback function with prototype init(forest, treeid, quadrant) called for each quadrant created to initialized the user data.\nreplace = nothing: callback function with prototype replace(forest, treeid, outgoing, incoming) called for each set of outgoing quadrants with their associated incoming quadrant.  Note  both outgoing and incoming are arrays with eltype Quadrant.\n\nSee @doc P4estTypes.P4est.p4est_coarsen_ext and @doc P4estTypes.P4est.p8est_coarsen_ext for more information about the underlying p4est coarsening functions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.comm-Tuple{Pxest}","page":"Reference","title":"P4estTypes.comm","text":"comm(forest)\n\nReturn the MPI Communicator used by the forest.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.connectivity-Tuple{Pxest}","page":"Reference","title":"P4estTypes.connectivity","text":"connectivity(forest)\n\nReturn the Connectivity used by the forest.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.coordinates-Tuple{Quadrant{4}}","page":"Reference","title":"P4estTypes.coordinates","text":"coordinates(quadrant::Quadrant{4})\n\nReturns a tuple of the quadrant's integer coordinates inside its tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.coordinates-Tuple{Quadrant{8}}","page":"Reference","title":"P4estTypes.coordinates","text":"coordinates(quadrant::Quadrant{8})\n\nReturns a tuple of the quadrant's integer coordinates inside its tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.expand!-Union{Tuple{X}, Tuple{GhostLayer{X}, Pxest{X}, LNodes{X}}} where X","page":"Reference","title":"P4estTypes.expand!","text":"expand!(ghost, forest, nodes)\n\nExpand the ghost layer to include all elements with nodes shared with neighboring ranks.\n\nConsider the following forest-of-quadtrees\n\n+-------+---+---+\n|       | 5 | 6 |\n|   2   +---+---+\n|       | 3 | 4 |\n+-------+---+---+\n|       |       |\n|   0   |   1   |\n|       |       |\n+-------+-------+\n\nthat is partitioned so rank 0 owns quadrants {0,1} and rank 1 owns quadrants {2, 3, 4, 5, 6}.  A fully connected ghost layer on rank 0 would include quadrants {2, 3, 4}.  Quadrant 5 shares a global node with rank 0 but is not in the fully connected ghost layer.  This function expands the ghost layer to include quadrants like this.\n\nSee sharers to get a list of the global nodes shared with neighboring ranks.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.ghostlayer-Union{Tuple{Pxest{X, T}}, Tuple{T}, Tuple{X}} where {X, T}","page":"Reference","title":"P4estTypes.ghostlayer","text":"ghostlayer(forest::Pxest{X}; connection=P4estTypes.CONNECT_FULL(Val(X)))\n\nConstruct a ghost layer of quadrants that neighbor the local to the rank for the given forest.  Here connection determines what neighboring quadrants to include (across face, edge, corner, or full) and can take the values:\n\nP4estTypes.CONNECT_FULL(Val(4)): get face and corner neighbors.\nP4estTypes.CONNECT_FULL(Val(8)): get face, edge, and corner neighbors.\nP4estTypes.CONNECT_FACE(Val(4)): get face neighbors.\nP4estTypes.CONNECT_FACE(Val(8)): get face neighbors.\nP4estTypes.CONNECT_EDGE(Val(8)): get face and edge neighbors.\nP4estTypes.CONNECT_CORNER(Val(4)): get face and corner neighbors.\nP4estTypes.CONNECT_CORNER(Val(8)):get face, edge, and corner neighbors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.ghosts-Union{Tuple{GhostLayer{X, T}}, Tuple{T}, Tuple{X}} where {X, T}","page":"Reference","title":"P4estTypes.ghosts","text":"ghosts(gl::GhostLayer)\n\nReturns an array-like structure with the Quadrants that neighbor the domain of the local rank.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.globalid-Tuple{LNodes, Int32}","page":"Reference","title":"P4estTypes.globalid","text":"globalid(nodes::LNodes, localid::p4est_locidx_t)\n\nReturns the global id associated with the node in LNodes with local id localid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.iterateforest-Union{Tuple{Pxest{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.iterateforest","text":"iterateforest(forest; kw...)\n\nExecute the callbacks passed as keyword arguments for every volume, face, edge, and corner of the rank-local forest.\n\nThe keyword arguments (kw...) for the iteration are:\n\nghost = nothing: the ghost layer associated for the mesh.  Used in face, edge, and corner callbacks for neighboring elements not rank local.\nvolume = nothing: Callback used for every volume (aka quadrant) of the local forest with the prototype volume(forest, ghost, quadrant, quadid, treeid, userdata).\nface = nothing: Not implemented yet.\nedge = nothing: Not implemented yet.\ncorner = nothing: Not implemented yet.\nuserdata = nothing: User data passed to the callbacks.\n\nSee @doc P4estTypes.P4est.p4est_iterate and @doc P4estTypes.P4est.p8est_iterate for more information about the iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.lengthofglobalquadrants-Tuple{Pxest}","page":"Reference","title":"P4estTypes.lengthofglobalquadrants","text":"lengthofglobalquadrants(forest)\n\nReturn the number of quadrants distributed across the whole forest.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.lengthoflocalquadrants-Tuple{Pxest}","page":"Reference","title":"P4estTypes.lengthoflocalquadrants","text":"lengthoflocalquadrants(forest)\n\nReturn the number of quadrants local to the rank.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.level-Tuple{Quadrant}","page":"Reference","title":"P4estTypes.level","text":"level(quadrant::Quadrant)\n\nReturns the level of refinement for the quadrant.  Level 0 is the coarsest level and P4estTypes.P4est.P4EST_QMAXLEVEL is the maximum refinement level.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.lnodes-Union{Tuple{Pxest{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.lnodes","text":"lnodes(forest::Pxest; ghost = nothing, degree = 1)\n\nConstruct a parallel node numbering for the forest. If the ghost layer ghost is not provided it will be constructed.\n\nA degree > 0 indicates that degree degree Lobotto nodes will be constructed.  A degree < 0 indicates that the boundary objects (faces, edges, and corners) will be numbered.\n\nSee @doc P4estTypes.P4est.p4est_lnodes_t and @doc P4estTypes.P4est.p8est_lnodes_t for a more detailed discussion of the numbering based on degree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.loaduserdata-Union{Tuple{Quadrant{X, T}}, Tuple{T}, Tuple{X}} where {X, T}","page":"Reference","title":"P4estTypes.loaduserdata","text":"loaduserdata(quadrant::Quadrant, data)\n\nReturn the user data data associated with the quadrant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.mirrors-Union{Tuple{GhostLayer{X, T}}, Tuple{T}, Tuple{X}} where {X, T}","page":"Reference","title":"P4estTypes.mirrors","text":"mirrors(gl::GhostLayer)\n\nReturns an array-like structure with the Quadrants in the local domain that are in neighboring rank's ghost layers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.offset-Tuple{P4estTypes.Tree}","page":"Reference","title":"P4estTypes.offset","text":"offset(tree::Tree)\n\nThe cumulative sum of the quadrants over earlier trees on this rank (locals only).\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.partition!-Union{Tuple{Pxest{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.partition!","text":"partition!(forest; kw...)\n\nPartition the quadrants of the forest.  By default this will partition the quadrants equally across the ranks of the forest.\n\nBy default sibling elements are split among the ranks.  This means they cannot be coarsened with coarsen! and can cause MPI dependent coarsening. If allow_for_coarsening==true then this is avoided by keeping sibling quadrants on the same rank.\n\nA weight(forest, treeid, quadrant) callback may provided (which gives the Float64 weight of each quadrant) for a weighted partitioning of the forest.\n\nAlternatively, the forest may be partitioned to equally distribute the globally numbered nodes via LNodes.  This is done by setting lnodes_degree to the node degree.  This requires the GhostLayer which if not passed in ghost will be created.\n\nThe keyword arguments (kw...) for the partitioning are:\n\nghost = nothing: GhostLayer used when partitioning by LNodes.\nlnodes_degree = nothing: partition based on LNodes if this is set to the degree.\nallow_for_coarsening = false: if true sibling groups that may be coarsened will be collect on the same rank.\nweight = nothing: callback that give the Float64 weight of each quadrant to perform a weighted partitioning.\n\nSee @doc P4estTypes.P4est.p4est_partition_ext, @doc P4estTypes.P4est.p8est_partition_ext, @doc P4estTypes.P4est.p4est_partition_lnodes, and @doc P4estTypes.P4est.p8est_partition_lnodes, for more information about the underlying p4est partition functions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.pxest-Union{Tuple{Connectivity{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.pxest","text":"pxest(connectivity::Connectivity{X}; kw...) where {X}\n\nGenerate a distributed forest of quadtrees (if X=4) or octrees (if X=8) based on connectivity.  Each element of connectivity becomes a tree root.\n\nThe connectivity is duplicated on all ranks but the leaves of the forest are split (based on a space-filling curve order) among the ranks.\n\nThe keyword arguments (kw...) that control the construction of the forest are:\n\ncomm = MPI.COMM_WORLD: the MPI Communicator object of the ranks sharing  the forest.\nmin_quadrants = 0: the minimum number of quadrants per rank.  (This makes the initial refinement pattern MPI.Comm_size specific.)\nmin_level = 0: the minimum level of quadrant refinement for the forest.\nfill_uniform = true: if true the forest will be filled with a uniform mesh otherwise it is the coarsest possible mesh.\ndata_type = Nothing: an isbitstype of the user data stored for each quadrant.\ninit_function = nothing: callback function with prototype init_function(forest, treeid, quadrant) called for each quadrant to initialized the user data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.quadrantstyle","page":"Reference","title":"P4estTypes.quadrantstyle","text":"quadrantndims(forest)\n\nReturns 2 if the forest quadrants are 2D and 3 if they are 3D.\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4estTypes.quadrantstyle-Union{Tuple{Pxest{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.quadrantstyle","text":"quadrantstyle(forest)\n\nReturns 4 if the forest quadrants are 2D and 8 if they are 3D.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.refine!-Union{Tuple{Pxest{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.refine!","text":"refine!(forest; refine = (_...) -> false, kw...)\n\nRefine the quadrants of the forest determined by the refine callback. The refine(forest, treeid, quadrant) callback is called for each quadrant local to the rank. If the callback returns true the quadrant will refine into multiple quadrants otherwise it will be untouched.\n\nThe other keyword arguments (kw...) for the refining are:\n\nrecursive: if true refining will be recursive otherwise each rank-local quadrant will only be visited once.\nmaxlevel = -1: the maximum level of refinement possible during this call.\ninit = nothing: callback function with prototype init(forest, treeid, quadrant) called for each quadrant created to initialized the user data.\nreplace = nothing: callback function with prototype replace(forest, treeid, outgoing, incoming) called for each outgoing quadrant with their associated incoming quadrants. Note both outgoing and incoming are arrays with eltype Quadrant.\n\nSee @doc P4estTypes.P4est.p4est_refine_ext and @doc P4estTypes.P4est.p8est_refine_ext for more information about the underlying p4est refinement functions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.refine-Tuple{Connectivity{4}, Any}","page":"Reference","title":"P4estTypes.refine","text":"refine(c::Connectivity{4}, nedge)\n\nReturns a new Connectivity that is c uniformly refined with nedge new trees in each direction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.refine-Tuple{Connectivity{8}, Any}","page":"Reference","title":"P4estTypes.refine","text":"refine(c::Connectivity{8}, nedge)\n\nReturns a new Connectivity that is c uniformly refined with nedge new trees in each direction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.savevtk-Union{Tuple{X}, Tuple{Any, Pxest{X}}} where X","page":"Reference","title":"P4estTypes.savevtk","text":"savevtk(prefix, forest; kw...)\n\nSave the distributed forest-of-octrees (or quadtrees) forest to a set of VTK files.\n\nA .vtu file with the file name prefix is created per rank storing the rank-local quadrants.  Further, .pvtu and .visit collection files are created for ease of importing the mesh into Paraview and Visit, respectively.\n\nThe keyword arguments (kw...) are:\n\nscale = 1.0: a scale < 1.0 places a visual gap between adjacent quadrants.\nwritetree = true: if true include the zero-based tree id in VTK cell data.\nwritelevel = true: if true include the quadrant level in VTK cell data.\nwriterank = true: if true include the MPI rank in VTK cell data.\nwraprank = 0: if wraprank > 0 the MPI rank is stored modulo wraprank.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.setverbosity-Tuple{P4estTypes.SC.LP.LogPriority}","page":"Reference","title":"P4estTypes.setverbosity","text":"P4estTypes.setverbosity(logpriority::P4estTypes.SC.LP.LogPriority)\n\nSets the verbosity of p4est. See P4estTypes.SC.LP.LogPriority for a list of valid priorities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.sharers-Tuple{LNodes}","page":"Reference","title":"P4estTypes.sharers","text":"sharers(nodes::LNodes)\n\nReturns a Dict mapping the neighboring rank with the global ids of the nodes shared between it and the local rank.\n\nNote, this Dict does not include an entry for the local rank.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.storeuserdata!-Union{Tuple{T}, Tuple{X}, Tuple{Quadrant{X, T}, T}} where {X, T}","page":"Reference","title":"P4estTypes.storeuserdata!","text":"storeuserdata!(quadrant::Quadrant, data)\n\nStore the user data data associated with the quadrant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.typeofquadrantuserdata-Union{Tuple{Pxest{X, T}}, Tuple{T}, Tuple{X}} where {X, T}","page":"Reference","title":"P4estTypes.typeofquadrantuserdata","text":"typeofquadrantuserdata(forest)\n\nReturn the user data type for the user data stored for each quadrant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.unsafe_element_nodes-Union{Tuple{LNodes{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.unsafe_element_nodes","text":"unsafe_element_nodes(nodes::LNodes)\n\nReturn an array containing the unique continuous node number for each local degree-of-freedom.\n\nSee @doc P4estTypes.P4est.p4est_lnodes_t and @doc P4estTypes.P4est.p8est_lnodes_t for a more details.\n\nNote, this unsafely wraps a C array.  So, you must ensure that the nodes structure is preserved while using the return value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.unsafe_face_code-Tuple{LNodes}","page":"Reference","title":"P4estTypes.unsafe_face_code","text":"unsafe_face_code(nodes::LNodes)\n\nReturn an array containing the face code for each quadrant of the mesh. The face code indicates which faces and edges of the quadrant are hanging.\n\nSee the p4est functions p4est_lnodes_decode and p8est_lnodes_decode to determine how to decode the face code.\n\nNote, this unsafely wraps a C array.  So, you must ensure that the nodes structure is preserved while using the return value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.unsafe_global_first_quadrant-Tuple{Pxest}","page":"Reference","title":"P4estTypes.unsafe_global_first_quadrant","text":"unsafe_global_first_quadrant(forest::Pxest)\n\nReturns 0-based indices into global quadrants.  This includes an extra entry at the end of the array so that 1-based range into the global quadrants for rank r can be built with\n\n(global_first_quadrant[r]+1):global_first_quadrant[r+1]\n\nNote, this unsafely wraps a C array.  So, you must ensure that the forest structure is preserved while using the return value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.unsafe_global_owned_count-Tuple{LNodes}","page":"Reference","title":"P4estTypes.unsafe_global_owned_count","text":"unsafe_global_owned_count(nodes::LNodes)\n\nReturn an array containing the number of independent nodes owned by each rank.\n\nSee @doc P4estTypes.P4est.p4est_lnodes_t and @doc P4estTypes.P4est.p8est_lnodes_t for a more details.\n\nNote, this unsafely wraps a C array.  So, you must ensure that the nodes structure is preserved while using the return value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.unsafe_local_num-Tuple{Quadrant}","page":"Reference","title":"P4estTypes.unsafe_local_num","text":"unsafe_local_num(quadrant::Quadrant)\n\nReturns the local_num field of the underlying quadrant.  This value is only sometimes set so the function is marked unsafe.  For example, it is set for quadrants returned by ghosts and mirrors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.unsafe_mirror_proc_mirrors-Union{Tuple{GhostLayer{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.unsafe_mirror_proc_mirrors","text":"unsafe_mirror_proc_mirrors(ghost::GhostLayer)\n\nReturns 0-based indices into mirrors.  This is used in conjunction with mirror_proc_offsets to get the mirror quadrants associated with each rank.  For example\n\nrrange = (mirror_proc_offsets[r]+1):mirror_proc_offsets[r+1]\nmirrors(ghost)[mirror_proc_mirrors(rrange)]\n\nselects the mirror quadrants associated with rank r.\n\nSee @doc P4estTypes.P4est.p4est_ghost_t and @doc P4estTypes.P4est.p8est_ghost_t for a more details.\n\nNote, this unsafely wraps a C array.  So, you must ensure that the ghost structure is preserved while using the return value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.unsafe_mirror_proc_offsets-Union{Tuple{GhostLayer{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.unsafe_mirror_proc_offsets","text":"unsafe_mirror_proc_offsets(ghost::GhostLayer)\n\nReturns 0-based indices into mirror_proc_mirrors for each rank.  This includes an extra entry at the end of the array so that 1-based range into mirror_proc_mirrors for rank r can be built with\n\n(mirror_proc_offsets[r]+1):mirror_proc_offsets[r+1]\n\nSee @doc P4estTypes.P4est.p4est_ghost_t and @doc P4estTypes.P4est.p8est_ghost_t for a more details.\n\nNote, this unsafely wraps a C array.  So, you must ensure that the ghost structure is preserved while using the return value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.unsafe_proc_offsets-Union{Tuple{GhostLayer{X}}, Tuple{X}} where X","page":"Reference","title":"P4estTypes.unsafe_proc_offsets","text":"unsafe_proc_offsets(ghost::GhostLayer)\n\nReturns 0-based indices into ghosts for each rank.  This includes an extra entry at the end of the array so that 1-based range into ghosts for rank r can be built with\n\n(proc_offsets[r]+1):proc_offsets[r+1]\n\nThus the ghost quadrants associated with rank r can be obtained with\n\nghosts(ghost)[(proc_offsets[r]+1):proc_offsets[r+1]]\n\nSee @doc P4estTypes.P4est.p4est_ghost_t and @doc P4estTypes.P4est.p8est_ghost_t for a more details.\n\nNote, this unsafely wraps a C array.  So, you must ensure that the ghost structure is preserved while using the return value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.unsafe_which_tree-Tuple{Quadrant}","page":"Reference","title":"P4estTypes.unsafe_which_tree","text":"unsafe_which_tree(quadrant::Quadrant)\n\nReturns the which_tree field of the underlying quadrant.  This value is only sometimes set so the function is marked unsafe.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4estTypes.uses_mpi-Tuple{}","page":"Reference","title":"P4estTypes.uses_mpi","text":"P4estTypes.uses_mpi()\n\nReturns true if the p4est C library uses MPI.\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [P4estTypes.SC.LP]","category":"page"},{"location":"reference/#P4estTypes.SC.LP.Always","page":"Reference","title":"P4estTypes.SC.LP.Always","text":"P4estTypes.SC.LP.Always\n\nLog priority indicating to log absolutely everything.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Debug","page":"Reference","title":"P4estTypes.SC.LP.Debug","text":"P4estTypes.SC.LP.Debug\n\nLog priority indicating to log any information on the internal state.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Default","page":"Reference","title":"P4estTypes.SC.LP.Default","text":"P4estTypes.SC.LP.Default\n\nThe libsc default log priority.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Error","page":"Reference","title":"P4estTypes.SC.LP.Error","text":"P4estTypes.SC.LP.Error\n\nLog priority indicating to log errors only.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Essential","page":"Reference","title":"P4estTypes.SC.LP.Essential","text":"P4estTypes.SC.LP.Essential\n\nLog priority indicating to log a few lines at most for a major api function.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Info","page":"Reference","title":"P4estTypes.SC.LP.Info","text":"P4estTypes.SC.LP.Info\n\nLog priority indicating to log most relevant things a function is doing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.LogPriority","page":"Reference","title":"P4estTypes.SC.LP.LogPriority","text":"P4estTypes.SC.LP.LogPriority\n\nAn abstract type for p4est and libsc log priorities.  The follow priorities are available:\n\nP4estTypes.SC.LP.Default: the libsc default.\nP4estTypes.SC.LP.Always: log absolutely everything.\nP4estTypes.SC.LP.Trace: prefix file and line number.\nP4estTypes.SC.LP.Debug: any information on the internal state.\nP4estTypes.SC.LP.Verbose: information on conditions, decisions.\nP4estTypes.SC.LP.Info: most relevant things a function is doing.\nP4estTypes.SC.LP.Statistics: important for consistency/performance.\nP4estTypes.SC.LP.Essential: a few lines at most for a major api function.\nP4estTypes.SC.LP.Production: log a few lines max per program.\nP4estTypes.SC.LP.Error: log errors only.\nP4estTypes.SC.LP.Silent: never log anything.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Production","page":"Reference","title":"P4estTypes.SC.LP.Production","text":"P4estTypes.SC.LP.Production\n\nLog priority indicating to log a few lines max per program.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Silent","page":"Reference","title":"P4estTypes.SC.LP.Silent","text":"P4estTypes.SC.LP.Silent\n\nLog priority indicating to never log anything.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Statistics","page":"Reference","title":"P4estTypes.SC.LP.Statistics","text":"P4estTypes.SC.LP.Statistics\n\nLog priority indicating to log important for consistency/performance.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Trace","page":"Reference","title":"P4estTypes.SC.LP.Trace","text":"P4estTypes.SC.LP.Trace\n\nLog priority indicating to log trace information with prefix file and line number.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4estTypes.SC.LP.Verbose","page":"Reference","title":"P4estTypes.SC.LP.Verbose","text":"P4estTypes.SC.LP.Verbose\n\nLog priority indicating to log information on conditions, decisions.\n\n\n\n\n\n","category":"type"},{"location":"#P4estTypes.jl","page":"Home","title":"P4estTypes.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"P4estTypes.jl provides a Julia type-based interface to the distributed (via MPI) forest-of-octrees library p4est by leveraging P4est.jl (which provides low-level Julia bindings to the p4est API).","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are encouraged. In particular only a small part of p4est is currently exposed. If there are additional functions you would like to use, please open an issue or pull request.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional examples and documentation improvements are also welcome.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use P4estTypes.jl in your work, please consider citing the following papers on p4est:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@ARTICLE{BursteddeWilcoxGhattas11,\n  author = {Carsten Burstedde and Lucas C. Wilcox and Omar Ghattas},\n  title = {{\\texttt{p4est}}: Scalable Algorithms for Parallel Adaptive Mesh\n           Refinement on Forests of Octrees},\n  journal = {SIAM Journal on Scientific Computing},\n  volume = {33},\n  number = {3},\n  pages = {1103-1133},\n  year = {2011},\n  doi = {10.1137/100791634}\n}\n\n@ARTICLE{IsaacBursteddeWilcoxEtAl15,\n  author = {Tobin Isaac and Carsten Burstedde and Lucas C. Wilcox and Omar Ghattas},\n  title = {Recursive algorithms for distributed forests of octrees},\n  journal = {SIAM Journal on Scientific Computing},\n  volume = {37},\n  number = {5},\n  pages = {C497-C531},\n  year = {2015},\n  doi = {10.1137/140970963}\n}","category":"page"},{"location":"refindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"refindex/","page":"Index","title":"Index","text":"","category":"page"}]
}
